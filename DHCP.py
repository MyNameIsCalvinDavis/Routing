from Headers import *
from Debug import *
import ipaddress
import time

# This DHCP S/C implements most of the "MUST" functionality
# described in RFC2131, with the exception being retransmission
# of lost or dropped packets. Not all options are implemented.

# For example, DHCPNAK is not implemented as it is technically
# "SHOULD" functionality per 3.1.4, so the server silently
# ignores invalid requests instead

# https://datatracker.ietf.org/doc/html/rfc2131#section-2.2
# https://www.netmanias.com/en/post/techdocs/5998/dhcp-network-protocol/understanding-the-basic-operations-of-dhcp
# https://avocado89.medium.com/dhcp-packet-analysis-c84827e162f0

# TODO: Implement DHCP Client retransmission / timeouts
# TODO: DHCP Snooping
# TODO: Verify lease expiration


class DHCPServerHandler:
    """
    Handles DHCP Discovery / Request / Renewal
    """
    def __init__(self, ip, nmask, haddr, gateway, DEBUG):
        """
        :param ip: DHCP Server IP, str
        :param nmask: Netmask of the served subnet, str
        """
        nmask = str(nmask)
        self.ip = ip
        self.nmask = nmask

        self.gateway = splitAddr(gateway)[0]
        print("DHCP made gateway", self.gateway, "from", splitAddr(gateway), "original", gateway)

        if splitAddr(gateway)[1] != self.nmask:
            raise ValueError("Mask conflict between gateway", splitAddr(gateway), "and self", self.nmask)

        # ipaddress doesn't like host bits
        # so get rid of the host bits
        
        #range_from_ip = ip.split("/")[0].split(".")
        #range_from_ip[-1] = "0"
        #range_from_ip = ".".join(range_from_ip)
        #
        #print(self.ip, self.nmask, range_from_ip, removeHostBits(range_from_ip))
        
        print("IP",self.ip, "NM", self.nmask, "GW", gateway)
        
        if self.nmask == 0: raise

        self.ip_range = [str(ip) for ip in ipaddress.IPv4Network(removeHostBits(ip) + "/" + nmask)]
        self.ip_range = self.ip_range[10:] # Reserve the first 10 IPs in a subnet for whatever
        try: self.ip_range.remove(ip)
        except: pass

        self.leased_ips = {}
        self.lease_offer = 20
        self.id = haddr
        self.DEBUG = DEBUG
        
        # Keep track of states for ongoing client transactions,
        # client is deleted after DHCP ACK
        #self.client_msgtype = {}

    
    def handleRequestedOptions(self, data):
        """
        Receive and parse opts (a list of #s) from the client's option 55
        Return a dict with each option filled out
        Not all options are implemented

        See https://www.iana.org/assignments/bootp-dhcp-parameters/bootp-dhcp-parameters.xhtml#options

        :param data: See `Headers.makePacket()`, dict
        :returns: dict that contains requested params and their values, dict
        """
        
        result = {}
        if not 55 in data["L3"]["Data"]["options"]:
            return result

        for opt in data["L3"]["Data"]["options"][55]: # TODO: What options can a client request?
            if opt == 1: # Subnet mask
                result[opt] = self.nmask
            if opt == 3: # Router Addr
                result[opt] = self.gateway
            if opt == 6: # DNS Server
                result[opt] = "" # Not doing DNS
            if opt == 51: # Lease Offer
                result[opt] = self.lease_offer
            if opt == 54: # DHCP Server IP
                result[opt] = self.ip

        return result
                
    def generateIP(self):
        """
        Generate an IP not currently leased out

        :returns: "X.X.X.X", str
        """
        while True:
            #x = "10.10.10." + str(random.randint(2, 254))
            x = random.choice(self.ip_range)
            #if self.DEBUG: print("(DHCP)", self.id, "Finding an IP:", x, "for client")
            if self.DEBUG: 
                Debug(self.id, "Finding an IP for client:", Debug.color(x, "blue"), 
                    color="green", f=self.__class__.__name__
                )
            if not x in self.leased_ips:
                return x

    def handleDHCP(self, data): # Send (O)ffer
        """
        Handle Discover / Request, then reply with Offer / ACK respectively. The 
        two return values for each section are the data packet generated by 
        Headers.makePacket(), and the link it's being sent on. The sent-on link
        is just the FromLink entry in the data packet, or the linkID the data originated from.

        Whether the data is unicast or broadcast on L3 DHCP is irrelevant; the response
        will always be sent back out on the same interface the request came in on to
        ensure interface outputs dont get mixed up
        
        :param data: See `Headers.makePacket()`, dict
        :returns: The response packet, dict
        :returns: The linkID it should be sent out on, str
        """
        
        if self.DEBUG:
            Debug(self.id, "My IP:", Debug.color(self.ip, "blue"), "=== Client IP:", Debug.color(data["L3"]["SIP"], "blue"), 
                color="green", f=self.__class__.__name__ 
            )
        # Process D(iscover) request
        if data["L3"]["Data"]["op"] == 1 and data["L3"]["Data"]["options"][53] == 1:  
            # Send DHCP Offer
            clientip = self.generateIP()

            # Check clients requested options & satisfy them, if any
            requested_options = self.handleRequestedOptions( data )

            # RFC2131 S4.3.1 Table 3
            # Server must send: 51      53      54      55 if applicable
            #                   Lease   MsgType SrvID   Requested Params
            server_options = {
                51: self.lease_offer,
                53: 2, # DHCP Offer
                54: self.ip # DHCP Server ID
            }

            options = mergeDicts(requested_options, server_options)
            if self.DEBUG:
                Debug(self.id, "Sending server options:", Debug.color(options, "white"), 
                    color="green", f=self.__class__.__name__
                )
            #print("DHCP Server opts sending:", options)

            # Broadcast (flags=0) a response (op=2) # TODO: Verify with table 4.3.1$3
            DHCP = createDHCPHeader(op=2, 
                    chaddr=data["L3"]["Data"]["chaddr"],
                    yiaddr=clientip,
                    options=options,
                    xid=data["L3"]["Data"]["xid"]
                )
            p4 = makePacket_L4_UDP(67, 68)
            p3 = makePacket_L3(self.ip, "255.255.255.255", DHCP, "UDP")
            
            # Check if the client wants the message broadcast or unicast
            p2 = makePacket_L2("IPv4", 
                    self.id, # From
                    MAC_BROADCAST if data["L3"]["Data"]["flags"] else data["L2"]["From"], # To
                    data["L2"]["FromLink"] # Onlink
                )

            p = makePacket(p2, p3, p4)

            #if self.DEBUG: print("(DHCP)", self.id, "received Discover from", data["L2"]["From"])
            #if self.DEBUG: print("(DHCP)", self.id, "sending Offer to", data["L2"]["From"])
            if self.DEBUG: 
                Debug(self.id, "received Discover from", data["L2"]["From"], ", sending offer", 
                    color="green", f=self.__class__.__name__
                )
            if self.DEBUG == 2: print(p)
            return p, data["L2"]["FromLink"]

        # Process R(equest)
        elif data["L3"]["Data"]["op"] == 1 and data["L3"]["Data"]["options"][53] == 3:
            # Send a DHCP Ack
            
            # Client sent option 50, the requested / assigned IP
            if data["L3"]["Data"]["ciaddr"] == "0.0.0.0": # R(equest)
                yiaddr = data["L3"]["Data"]["options"][50]
            else: #R(enewal)
                yiaddr = data["L3"]["Data"]["ciaddr"]
            
            # Check clients requested options & satisfy them, if any
            requested_options = self.handleRequestedOptions( data )

            # RFC2131 S4.3.1 Table 3
            # Server must send: 51      53      54      55 if applicable
            #                   Lease   MsgType SrvID   Requested Params
            server_options = {
                51: self.lease_offer,
                53: 5, # DHCP ACK
                54: self.ip # DHCP Server ID
            }

            options = mergeDicts(requested_options, server_options)

            # Broadcast (flags=0) a response (op=2) # TODO: Verify with table 4.3.1$3
            DHCP = createDHCPHeader(op=2, 
                    chaddr=data["L3"]["Data"]["chaddr"],
                    yiaddr=yiaddr,
                    options=options,
                    xid=data["L3"]["Data"]["xid"]
                )

            p4 = makePacket_L4_UDP(67, 68)
            p3 = makePacket_L3(self.ip, "255.255.255.255", DHCP, "UDP")

            # Check if the client wants the message broadcast or unicast
            p2 = makePacket_L2("IPv4", 
                    self.id, # From
                    MAC_BROADCAST if data["L3"]["Data"]["flags"] else data["L2"]["From"], # To
                    data["L2"]["FromLink"] # Onlink
                )
            p = makePacket(p2, p3, p4)

            if self.DEBUG: 
                Debug(self.id, "received Request from", data["L2"]["From"], 
                    color="green", f=self.__class__.__name__
                )
                Debug(self.id, "sending ACK to", data["L2"]["From"], 
                    color="green", f=self.__class__.__name__
                )
            
            # IP: (chaddr, lease_offer, lease_give_time)
            # Update leased IP
    
            
            # If client defines a client identifier (61), use it
            # otherwise clientID is chaddr + IP
            # TODO: Find out how this table is actually formatted
            if 61 in data["L3"]["Data"]["options"]:
                self.leased_ips[yiaddr] = (data["L3"]["Data"]["options"][61], self.lease_offer, time.time())
            else:
                combo = data["L2"]["From"] + yiaddr
                self.leased_ips[yiaddr] = (combo, self.lease_offer, time.time())

            return p, data["L2"]["FromLink"]

        else:
            if self.DEBUG:
                Debug(self.id, "Ignoring", 
                    color="yellow", f=self.__class__.__name__
                )
            #if self.DEBUG: print(self.id, "Ignoring")

# Not a Device, just deals with DHCP functionality
# then returns output to the host / whatever it's inside of
class DHCPClientHandler:
    def __init__(self, haddr, interfaces, debug=1):

        self.id = haddr
        self.interfaces = interfaces
        self.DEBUG = debug
        
        # 1 Subnet mask
        # 3 Router ID
        # 6 DNS Server
        self.requested_options = [1,3,6]
        
        # L3
        self.ip = ""
        self.nmask = ""
        self.gateway = ""
        self.offered_ip = ""
        self.lease = (-1, -1) # (leaseTime, time (s) received the lease)
        self.DHCP_FLAG = 0 # 0: No IP --- 1: Awaiting ACK --- 2: Received ACK & has active IP
        self.DHCP_MAC = ""
        self.DHCP_IP = ""
        self.current_tx = ""

    def handleDHCP(self, data):
        """
        Handle Offer / ACK, reply with Response. See `DHCPServerHandler.handleDHCP`.
        Will return None, None on ACK

        :param data: See `Headers.makePacket()`, dict
        :returns: The response packet, dict
        :returns: The linkID it should be sent out on, str
        """
        ######

        #if self.DEBUG == 2: print("(DHCP.py)", self.id, "got", data)

        # Process O(ffer)
        if data["L3"]["Data"]["op"] == 2 and data["L3"]["Data"]["options"][53] == 2 and data["L3"]["Data"]["xid"] == self.current_tx:  
            # Send R(equest)
            
            #if self.DEBUG: print("(DHCP)", self.id, "received DHCP Offer, sending Request (broadcast)")
            if self.DEBUG:
                Debug(self.id, "received DHCP Offer, sending Request (broadcast)", 
                    color="green", f=self.__class__.__name__
                )
            self.DHCP_FLAG = 1
            self.offered_ip = data["L3"]["Data"]["yiaddr"]
            self.DHCP_IP = data["L3"]["SIP"] if not 54 in data["L3"]["Data"]["options"] else data["L3"]["Data"]["options"][54]
            #print("    DHCP IP: ", self.DHCP_IP)
            self.DHCP_MAC = data["L2"]["From"] # Not reliable if not on same network

            # RFC2131 S4.4.1 Table 5
            # Client must send: 50      53      54
            #                   AddrRq  MsgType SrvID                                
            options = {
                50: self.offered_ip,
                53: 3, # Request
                54: self.DHCP_IP, # DHCP siaddr
                55: self.requested_options # Same as before
            }

            DHCP = createDHCPHeader(chaddr=self.id, flags=1, options=options, xid=data["L3"]["Data"]["xid"])

            p4 = makePacket_L4_UDP(68, 67)
            p3 = makePacket_L3("0.0.0.0", "255.255.255.255", DHCP, "UDP")
            p2 = makePacket_L2("IPv4", self.id, MAC_BROADCAST)
            p = makePacket(p2, p3, p4)
            
            # Send it out on the same link we received data on
            return p, data["L2"]["FromLink"]

        # Process A(CK)
        elif data["L3"]["Data"]["op"] == 2 and data["L3"]["Data"]["options"][53] == 5 and data["L3"]["Data"]["xid"] == self.current_tx: 
            
            if 1 in self.requested_options:
                self.nmask = data["L3"]["Data"]["options"][1]
            if 3 in self.requested_options:
                self.gateway = data["L3"]["Data"]["options"][3]
            # if 6 in ... (DNS)

            self.ip = data["L3"]["Data"]["yiaddr"]
            self.lease = (data["L3"]["Data"]["options"][51], int(time.time()) )
            self.lease_left = (self.lease[0] + self.lease[1]) - int(time.time())
            self.DHCP_FLAG = 2
            #self.current_xid = -1
            #if self.DEBUG: print("(DHCP)", self.id, "received DHCP ACK from", data["L2"]["From"]+".", "New IP:", self.ip)
            if self.DEBUG: 
                Debug(self.id, "received DHCP ACK from", data["L2"]["From"], 
                    color="green", f=self.__class__.__name__
                )
        else:
            if self.DEBUG: genericIgnoreMessage("DHCP", data["L2"]["From"])
        
        # Upon receiving an ack, return nothing
        return None, None

    # Send D(iscover) or R(equest)
    def sendDHCP(self, context, onLinkID=None):
        """
        Send (return) a DHCP Discover, or Request message.

        :param context: "Init" or "Renew", str 
        :param onLinkID: ID of link to be sent out on, str
        :returns: The response packet, dict
        :returns: The linkID it should be sent out on, str
        """
        if onLinkID == None:
            onLink = self.interfaces[0].id
        
        # Send D(iscover)
        if context.lower() == "init": 
            if self.DEBUG:
                Debug(self.id, "sending DHCP Discover", 
                    color="green", f=self.__class__.__name__
                )
            
            # RFC2131 S4.4.1 Table 5
            # Client must send: 53
            #                   MsgType
            options = {
                53: 1, # Discover
                55: self.requested_options
            }

            DHCP = createDHCPHeader(chaddr=self.id, options=options)
            
            p4 = makePacket_L4_UDP(68, 67)
            p3 = makePacket_L3("0.0.0.0", "255.255.255.255", DHCP, "UDP") # MAC included
            p2 = makePacket_L2("IPv4", self.id, MAC_BROADCAST, onLinkID)
            p = makePacket(p2, p3, p4)

            self.current_tx = DHCP["xid"]
            return p, onLinkID
        
        # Send R(equest) renewal
        if context.lower() == "renew":
            if self.DEBUG: 
                Debug(self.id, "sending DHCP Request Renewal", Debug.color(self.DHCP_IP, "blue"), 
                    f=self.__class__.__name__
                )
            #print("(DHCP)", self.id, "sending DHCP Request (Renewal) ==>", self.DHCP_IP)

            # RFC2131 S4.4.1 Table 5
            # Client must send: 53
            #                   MsgType
            options = {
                53: 3, # Request
                55: self.requested_options
            }

            # Renew: ciaddr filled (NOT option 50)
            DHCP = createDHCPHeader(chaddr=self.id, ciaddr=self.ip, options=options)

            # Now that the IP is active, unicast to DHCP server
            p4 = makePacket_L4_UDP(68, 67)
            p3 = makePacket_L3(self.ip, self.DHCP_IP, DHCP, "UDP")
            p2 = makePacket_L2("IPv4", self.id, self.DHCP_MAC)
            p = makePacket(p2, p3, p4)

            self.current_tx = DHCP["xid"]
            return p, onLinkID
